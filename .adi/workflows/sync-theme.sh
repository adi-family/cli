#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"
THEME_DIR="$ROOT_DIR/packages/theme"
THEMES_JSON="$THEME_DIR/themes.json"
STATUS_JSON="$THEME_DIR/status-colors.json"
OUT_DIR="$THEME_DIR/generated"

mkdir -p "$OUT_DIR"

if ! command -v python3 &>/dev/null; then
  echo "Error: python3 is required" >&2
  exit 1
fi

if [ ! -f "$THEMES_JSON" ]; then
  echo "Error: $THEMES_JSON not found" >&2
  exit 1
fi

if [ ! -f "$STATUS_JSON" ]; then
  echo "Error: $STATUS_JSON not found" >&2
  exit 1
fi

python3 - "$THEMES_JSON" "$STATUS_JSON" "$OUT_DIR" <<'PYTHON'
import json, sys, os

themes_path, status_path, out_dir = sys.argv[1], sys.argv[2], sys.argv[3]

with open(themes_path) as f:
    data = json.load(f)
with open(status_path) as f:
    status = json.load(f)

default_theme = data["defaultTheme"]
themes = data["themes"]
fonts = data.get("fonts", {})
default_fonts = fonts.get("default", {
    "heading": "'Inter', system-ui, sans-serif",
    "body": "'Inter', system-ui, sans-serif",
    "monoHeading": "'JetBrains Mono', 'Fira Code', monospace",
    "monoBody": "'JetBrains Mono', 'Fira Code', monospace",
})

# --- token mapping: camelCase -> CSS custom property suffix ---
TOKEN_MAP = [
    ("bg", "bg"),
    ("surface", "surface"),
    ("surfaceAlt", "surface-alt"),
    ("accent", "accent"),
    ("accentSoft", "accent-soft"),
    ("text", "text"),
    ("textMuted", "text-muted"),
    ("border", "border"),
    ("gradient", "gradient"),
]

STATUS_MAP = [
    ("success", "success"),
    ("successSoft", "success-soft"),
    ("error", "error"),
    ("errorSoft", "error-soft"),
    ("warning", "warning"),
    ("warningSoft", "warning-soft"),
    ("info", "info"),
]

FONT_MAP = [
    ("heading", "font-heading"),
    ("body", "font-body"),
    ("monoHeading", "font-mono-heading"),
    ("monoBody", "font-mono-body"),
]

def get_fonts(theme_id):
    """Get font config for a theme, falling back to default."""
    theme_fonts = fonts.get(theme_id, {})
    return {k: theme_fonts.get(k, default_fonts[k]) for k in default_fonts}

def css_vars(mode_obj, indent="  "):
    lines = []
    for key, prop in TOKEN_MAP:
        lines.append(f"{indent}--adi-{prop}: {mode_obj[key]};")
    return "\n".join(lines)

def css_font_vars(font_obj, indent="  "):
    lines = []
    for key, prop in FONT_MAP:
        lines.append(f"{indent}--adi-{prop}: {font_obj[key]};")
    return "\n".join(lines)

def css_status_vars(mode_name, indent="  "):
    lines = []
    for key, prop in STATUS_MAP:
        lines.append(f"{indent}--adi-{prop}: {status[mode_name][key]};")
    return "\n".join(lines)

# ─── Generate CSS ───
css_lines = ["/* Generated by sync-theme — do not edit manually */", ""]

# Default theme (:root = dark)
default = themes[default_theme]
default_font = get_fonts(default_theme)
css_lines.append(f"/* ─── Default theme: {default_theme} (dark) ─── */")
css_lines.append(":root {")
css_lines.append(css_vars(default["dark"]))
css_lines.append("")
css_lines.append("  /* Fonts */")
css_lines.append(css_font_vars(default_font))
css_lines.append("")
css_lines.append("  /* Status (universal) */")
css_lines.append(css_status_vars("dark"))
css_lines.append("}")
css_lines.append("")

# Light mode for default theme (fonts don't change with mode)
css_lines.append("/* ─── Light mode ─── */")
css_lines.append('[data-mode="light"], .light {')
css_lines.append(css_vars(default["light"]))
css_lines.append("")
css_lines.append(css_status_vars("light"))
css_lines.append("}")
css_lines.append("")

# Auto light via system preference
css_lines.append("/* Auto light via system preference */")
css_lines.append("@media (prefers-color-scheme: light) {")
css_lines.append('  :root:not([data-mode="dark"]):not(.dark) {')
css_lines.append(css_vars(default["light"], "    "))
css_lines.append("")
css_lines.append(css_status_vars("light", "    "))
css_lines.append("  }")
css_lines.append("}")
css_lines.append("")

# Per-theme overrides (skip default — already in :root)
for theme_id, theme in themes.items():
    if theme_id == default_theme:
        continue

    theme_font = get_fonts(theme_id)
    css_lines.append(f'/* ─── Theme: {theme_id} ─── */')

    # Dark (includes fonts — fonts are per-theme, not per-mode)
    css_lines.append(f'[data-theme="{theme_id}"] {{')
    css_lines.append(css_vars(theme["dark"]))
    css_lines.append("")
    css_lines.append(css_font_vars(theme_font))
    css_lines.append("}")

    # Light
    css_lines.append(f'[data-theme="{theme_id}"][data-mode="light"],')
    css_lines.append(f'[data-theme="{theme_id}"].light {{')
    css_lines.append(css_vars(theme["light"]))
    css_lines.append("}")

    # Auto light
    css_lines.append("@media (prefers-color-scheme: light) {")
    css_lines.append(f'  [data-theme="{theme_id}"]:not([data-mode="dark"]):not(.dark) {{')
    css_lines.append(css_vars(theme["light"], "    "))
    css_lines.append("  }")
    css_lines.append("}")
    css_lines.append("")

css_out = os.path.join(out_dir, "adi-theme.css")
with open(css_out, "w") as f:
    f.write("\n".join(css_lines) + "\n")
print(f"  ✓ {css_out}")

# ─── Generate Rust ───
def rust_str(val):
    return f'"{val}"'

rs_lines = [
    "// Generated by sync-theme — do not edit manually",
    "",
    "pub struct ThemeFonts {",
    "    pub heading: &'static str,",
    "    pub body: &'static str,",
    "    pub mono_heading: &'static str,",
    "    pub mono_body: &'static str,",
    "}",
    "",
    "pub struct ThemeMode {",
    "    pub bg: &'static str,",
    "    pub surface: &'static str,",
    "    pub surface_alt: &'static str,",
    "    pub accent: &'static str,",
    "    pub accent_soft: &'static str,",
    "    pub text: &'static str,",
    "    pub text_muted: &'static str,",
    "    pub border: &'static str,",
    "    pub gradient: &'static str,",
    "}",
    "",
    "pub struct Theme {",
    "    pub id: &'static str,",
    "    pub name: &'static str,",
    "    pub accent: &'static str,",
    "    pub fonts: ThemeFonts,",
    "    pub dark: ThemeMode,",
    "    pub light: ThemeMode,",
    "}",
    "",
    "pub const THEMES: &[Theme] = &[",
]

for theme_id, theme in themes.items():
    tf = get_fonts(theme_id)
    rs_lines.append(f"    Theme {{")
    rs_lines.append(f'        id: {rust_str(theme_id)},')
    rs_lines.append(f'        name: {rust_str(theme["name"])},')
    rs_lines.append(f'        accent: {rust_str(theme["accent"])},')
    rs_lines.append(f"        fonts: ThemeFonts {{")
    rs_lines.append(f'            heading: {rust_str(tf["heading"])},')
    rs_lines.append(f'            body: {rust_str(tf["body"])},')
    rs_lines.append(f'            mono_heading: {rust_str(tf["monoHeading"])},')
    rs_lines.append(f'            mono_body: {rust_str(tf["monoBody"])},')
    rs_lines.append(f"        }},")
    for mode_name in ("dark", "light"):
        m = theme[mode_name]
        rs_lines.append(f"        {mode_name}: ThemeMode {{")
        rs_lines.append(f'            bg: {rust_str(m["bg"])},')
        rs_lines.append(f'            surface: {rust_str(m["surface"])},')
        rs_lines.append(f'            surface_alt: {rust_str(m["surfaceAlt"])},')
        rs_lines.append(f'            accent: {rust_str(m["accent"])},')
        rs_lines.append(f'            accent_soft: {rust_str(m["accentSoft"])},')
        rs_lines.append(f'            text: {rust_str(m["text"])},')
        rs_lines.append(f'            text_muted: {rust_str(m["textMuted"])},')
        rs_lines.append(f'            border: {rust_str(m["border"])},')
        rs_lines.append(f'            gradient: {rust_str(m["gradient"])},')
        rs_lines.append(f"        }},")
    rs_lines.append(f"    }},")

rs_lines.append("];")
rs_lines.append("")
rs_lines.append(f'pub const DEFAULT_THEME: &str = {rust_str(default_theme)};')
rs_lines.append("")
rs_lines.append("pub fn find_theme(id: &str) -> Option<&'static Theme> {")
rs_lines.append("    THEMES.iter().find(|t| t.id == id)")
rs_lines.append("}")
rs_lines.append("")

rs_out = os.path.join(out_dir, "themes.rs")
with open(rs_out, "w") as f:
    f.write("\n".join(rs_lines))
print(f"  ✓ {rs_out}")

print(f"\nSync complete — {len(themes)} themes generated.")
PYTHON

echo "Done."
