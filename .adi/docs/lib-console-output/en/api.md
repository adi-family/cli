<!-- 
  Auto-generated documentation for lib-console-output
  Language: English
  Generated: 2026-02-01T01:01:18Z
  
  This file was generated by: adi workflow autodoc
  To regenerate: adi workflow autodoc --force
-->

# lib-console-output

A unified console output abstraction library for Rust applications that provides consistent logging, progress indication, and user input across different output modes (text and JSON stream).

## Overview

`lib-console-output` is designed to handle all console interaction needs in a flexible way. It supports two primary modes:
- **Text mode**: Traditional console output with colors and interactive features
- **JSON stream mode**: Structured output for programmatic consumption or remote interfaces

The library provides logging with multiple levels, interactive user input components (select, confirm, text input), and various progress indicators (spinners, progress bars, step progress).

## Installation

Add this to your `Cargo.toml`:

```toml
[dependencies]
lib-console-output = "0.1.0"
```

## Quick Start

```rust
use lib_console_output::{info, success, confirm, select, SelectOption};

fn main() {
    // Simple logging
    info("Application started");
    
    // User confirmation
    if let Some(true) = confirm("Do you want to continue?") {
        success("User confirmed, proceeding...");
    }
    
    // Selection menu
    let options = vec![
        SelectOption::new("Option 1", "value1"),
        SelectOption::new("Option 2", "value2"),
    ];
    
    if let Some(choice) = select("Choose an option:", options) {
        info(&format!("User selected: {}", choice));
    }
}
```

## API Reference

### Core Console Functions

#### Logging Functions

```rust
// Basic logging at different levels
lib_console_output::trace("Detailed debug information");
lib_console_output::debug("Debug information");  
lib_console_output::info("General information");
lib_console_output::success("Operation completed successfully");
lib_console_output::warn("Warning message");
lib_console_output::error("Error occurred");
```

#### Data Output

```rust
use serde::Serialize;

#[derive(Serialize)]
struct Config { name: String, enabled: bool }

let config = Config { name: "test".into(), enabled: true };

// Output structured data
lib_console_output::data(&config);
```

### Console Configuration

#### `Console`

The main console instance that handles all output operations.

```rust
use lib_console_output::{Console, ConsoleConfig, OutputMode, Level};

// Create custom console
let config = ConsoleConfig::default()
    .with_mode(OutputMode::JsonStream)
    .with_min_level(Level::Info)
    .with_colors(false);

let console = Console::new(config);
console.info("Custom console message");

// Use global console
let console = lib_console_output::console();
console.debug("Using global instance");
```

#### `ConsoleConfig`

Configuration for console behavior.

```rust
// From environment variables
let config = ConsoleConfig::from_env();

// Manual configuration
let config = ConsoleConfig::text()
    .with_min_level(Level::Debug)
    .with_colors(true);
```

**Environment Variables:**
- `SILK_MODE`: Set to "json" for JSON stream mode
- `NO_COLOR`: Disable color output
- `VERBOSE`: Enable verbose logging
- `QUIET`: Minimize output

### Input Components

#### Text Input

```rust
use lib_console_output::{text_input, Input};

// Simple text input
if let Some(name) = text_input("Enter your name:") {
    println!("Hello, {}!", name);
}

// Advanced text input with validation
let email = Input::new("Enter email:")
    .placeholder("user@example.com")
    .required()
    .validate(|input| {
        if input.contains('@') {
            Ok(())
        } else {
            Err("Invalid email format".into())
        }
    })
    .run();
```

#### Confirmation

```rust
use lib_console_output::{confirm, Confirm};

// Simple confirmation
if let Some(true) = confirm("Delete all files?") {
    println!("Files deleted");
}

// With default value
let result = Confirm::new("Save changes?")
    .default(true)
    .run();
```

#### Selection

```rust
use lib_console_output::{select, Select, SelectOption};

let options = vec![
    SelectOption::new("Development", "dev")
        .with_description("Development environment"),
    SelectOption::new("Production", "prod")
        .with_description("Production environment"),
];

if let Some(env) = select("Select environment:", options) {
    println!("Selected: {}", env);
}

// With default selection
let result = Select::new("Choose option:")
    .items(vec![("Option 1", 1), ("Option 2", 2)])
    .default(0)
    .run();
```

#### Multi-Selection

```rust
use lib_console_output::{multi_select, MultiSelect, SelectOption};

let features = vec![
    SelectOption::new("Authentication", "auth"),
    SelectOption::new("Database", "db"),
    SelectOption::new("API", "api"),
];

if let Some(selected) = multi_select("Select features:", features) {
    println!("Enabled features: {:?}", selected);
}

// With constraints
let result = MultiSelect::new("Choose technologies:")
    .items(vec![("React", "react"), ("Vue", "vue"), ("Angular", "angular")])
    .min(1)
    .max(2)
    .defaults(vec![0])
    .run();
```

#### Password Input

```rust
use lib_console_output::{password, Password};

// Simple password
if let Some(pwd) = password("Enter password:") {
    println!("Password length: {}", pwd.len());
}

// With confirmation
let result = Password::new("Enter new password:")
    .confirm("Confirm password:")
    .mask('*')
    .run();
```

### Progress Indicators

#### Spinner

```rust
use lib_console_output::{spinner, progress};

let mut spin = spinner("Processing...");
spin.start();

// Simulate work
std::thread::sleep(std::time::Duration::from_secs(2));

spin.success(Some("Processing complete"));
// or spin.fail(Some("Processing failed"), Some("Network error"));
```

#### Progress Bar

```rust
use lib_console_output::progress_bar;

let mut bar = progress_bar(100, "Downloading...");
bar.start();

for i in 0..=100 {
    bar.set(i);
    std::thread::sleep(std::time::Duration::from_millis(50));
}

bar.success(Some("Download complete"));
```

#### Step Progress

```rust
use lib_console_output::steps;

let mut progress = steps(3, "Installation");
progress.start();

progress.next_step("Installing dependencies");
// ... do work ...

progress.next_step("Configuring system");
// ... do work ...

progress.next_step("Finalizing setup");
// ... do work ...

progress.success(Some("Installation complete"));
```

#### Multi-Progress

```rust
use lib_console_output::progress::MultiProgress;

let mut multi = MultiProgress::new();
let task1 = multi.add("Task 1");
let task2 = multi.add("Task 2");

multi.start_item(task1);
// ... do task 1 work ...
multi.complete_item(task1, Some("Task 1 done"));

multi.start_item(task2);
// ... do task 2 work ...
multi.complete_item(task2, Some("Task 2 done"));
```

### Styling and Icons

#### Level Icons

```rust
use lib_console_output::{icons, Level, level_icon};

// Predefined icons
println!("{} Success!", icons::success());
println!("{} Error occurred", icons::error());
println!("{} Warning", icons::warning());
println!("{} Information", icons::info());
println!("{} Debug info", icons::debug());

// Level-based icons
let icon = level_icon(Level::Success);
println!("{} Operation completed", icon);
```

### Output Message Builder

```rust
use lib_console_output::{MessageBuilder, OutputMessage, Level};

let msg = OutputMessage::new(Level::Info, "User action")
    .with_field("user_id", 123)
    .with_field("action", "login")
    .with_source("auth_service");

// Output the structured message
lib_console_output::message(&msg);

// Or use builder pattern
let console = lib_console_output::console();
console.message(Level::Info, "Database query")
    .field("table", "users")
    .field("duration_ms", 45)
    .source("database");
```

## Common Patterns

### Application Setup

```rust
use lib_console_output::{init, ConsoleConfig, Level};

fn main() {
    // Initialize console from environment
    init(ConsoleConfig::from_env());
    
    // Or with custom config
    init(ConsoleConfig::text()
        .with_min_level(Level::Info)
        .with_colors(true));
    
    run_application();
}

fn run_application() {
    lib_console_output::info("Application started");
    // ... rest of your application
}
```

### Interactive CLI Workflow

```rust
use lib_console_output::{confirm, select, text_input, SelectOption, success, error};

fn interactive_setup() -> Result<Config, String> {
    let project_name = text_input("Project name:")
        .ok_or("Project name required")?;
    
    let template = select("Choose template:", vec![
        SelectOption::new("Web App", "web"),
        SelectOption::new("CLI Tool", "cli"), 
        SelectOption::new("Library", "lib"),
    ]).ok_or("Template selection required")?;
    
    if confirm("Initialize git repository?").unwrap_or(false) {
        success("Git repository will be initialized");
    }
    
    Ok(Config { project_name, template })
}

struct Config {
    project_name: String,
    template: String,
}
```

### Long-Running Operations with Progress

```rust
use lib_console_output::{spinner, progress_bar, success, error};

fn download_and_process() {
    // Step 1: Download with progress bar
    let mut download = progress_bar(1024 * 1024, "Downloading data...");
    download.start();
    
    for chunk in 0..=1024*1024 {
        download.inc();
        if chunk % 10000 == 0 {
            std::thread::sleep(std::time::Duration::from_millis(1));
        }
    }
    download.success(Some("Download complete"));
    
    // Step 2: Process with spinner
    let mut process = spinner("Processing data...");
    process.start();
    
    std::thread::sleep(std::time::Duration::from_secs(2));
    
    process.success(Some("Processing complete"));
    success("Operation finished successfully");
}
```

## Error Handling

The library uses `Option` types for user input operations, where `None` indicates the user cancelled or the operation failed:

```rust
use lib_console_output::{text_input, error};

match text_input("Enter configuration:") {
    Some(config) => {
        // Process the input
        println!("Config: {}", config);
    }
    None => {
        error("Operation cancelled by user");
        std::process::exit(1);
    }
}
```

For validation errors in input components:

```rust
use lib_console_output::Input;

let result = Input::new("Enter port:")
    .validate(|input| {
        input.parse::<u16>()
            .map(|_| ())
            .map_err(|_| "Please enter a valid port number (1-65535)".to_string())
    })
    .run();
```

## JSON Stream Mode

When `OutputMode::JsonStream` is enabled, all operations output structured JSON for programmatic consumption:

```rust
use lib_console_output::{init, ConsoleConfig, OutputMode, info, confirm};

// Enable JSON mode
init(ConsoleConfig::default().with_mode(OutputMode::JsonStream));

info("Starting operation");
// Outputs: {"timestamp":"2024-01-01T12:00:00Z","level":"info","message":"Starting operation"}

if let Some(result) = confirm("Proceed?") {
    info(&format!("User responded: {}", result));
}
// Input request: {"type":"confirm","id":"...","prompt":"Proceed?","timestamp":"..."}
// Response expected: {"type":"confirm_response","id":"...","value":true,"timestamp":"..."}
```

## See Also

- [console](https://docs.rs/console/) - Terminal utilities used internally
- [serde](https://docs.rs/serde/) - Serialization framework for structured output
- [chrono](https://docs.rs/chrono/) - Date and time handling
